<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Staš's Plane</title>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      display: flex;
      justify-content: center;
      align-items: center;
      min-height: 100vh;
      background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
      font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
      overflow: hidden;
    }

    .back-btn {
      position: fixed;
      top: 20px;
      left: 20px;
      padding: 10px 20px;
      background: rgba(74, 158, 255, 0.2);
      border: 2px solid #4a9eff;
      border-radius: 8px;
      color: #4a9eff;
      font-family: inherit;
      font-size: 14px;
      cursor: pointer;
      text-decoration: none;
      z-index: 1000;
      transition: all 0.2s;
    }
    .back-btn:hover {
      background: rgba(74, 158, 255, 0.4);
      transform: scale(1.05);
    }

    .game-container {
      position: relative;
    }

    canvas {
      border: 4px solid #4a9eff;
      border-radius: 10px;
      box-shadow: 0 0 30px rgba(74, 158, 255, 0.3);
    }

    .ui-overlay {
      position: absolute;
      top: 20px;
      left: 20px;
      color: white;
      font-size: 20px;
      text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.5);
      z-index: 10;
    }

    .score {
      font-weight: bold;
    }

    .hud {
      font-size: 14px;
      color: #aaffaa;
      margin-top: 5px;
      font-family: monospace;
    }

    .start-screen,
    .game-over-screen {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      display: flex;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      background: rgba(0, 0, 0, 0.7);
      border-radius: 10px;
      z-index: 20;
    }

    .start-screen h1,
    .game-over-screen h1 {
      color: #4a9eff;
      font-size: 48px;
      margin-bottom: 20px;
      text-shadow: 0 0 20px rgba(74, 158, 255, 0.5);
    }

    .start-screen p,
    .game-over-screen p {
      color: #fff;
      font-size: 18px;
      margin-bottom: 30px;
    }

    .final-score {
      color: #ffd700;
      font-size: 32px;
      margin-bottom: 20px;
    }

    button {
      padding: 15px 40px;
      font-size: 20px;
      background: linear-gradient(135deg, #4a9eff 0%, #2d7dd2 100%);
      color: white;
      border: none;
      border-radius: 30px;
      cursor: pointer;
      transition: transform 0.2s, box-shadow 0.2s;
      box-shadow: 0 5px 20px rgba(74, 158, 255, 0.4);
    }

    button:hover {
      transform: scale(1.05);
      box-shadow: 0 8px 30px rgba(74, 158, 255, 0.6);
    }

    .controls {
      color: #aaa;
      font-size: 14px;
      margin-top: 20px;
    }

    .hidden {
      display: none !important;
    }
  </style>
</head>

<body>
  <a href="../index.html" class="back-btn">← Menu</a>
  <div class="game-container">
    <canvas id="gameCanvas" width="800" height="500"></canvas>

    <div class="ui-overlay">
      <div class="score">Score: <span id="scoreDisplay">0</span></div>
      <div class="hud">ALT: <span id="altDisplay">0</span>ft | SPD: <span id="spdDisplay">0</span>kts</div>
    </div>

    <div class="start-screen" id="startScreen">
      <h1>✈️ Staš's Plane</h1>
      <p>Dodge incoming missiles and collect power-ups!</p>
      <button onclick="startGame()">Start Game</button>
      <p class="controls">Use ↑↓ Arrow Keys or W/S to fly</p>
    </div>

    <div class="game-over-screen hidden" id="gameOverScreen">
      <h1>Game Over!</h1>
      <div class="final-score">Score: <span id="finalScore">0</span></div>
      <button onclick="startGame()">Play Again</button>
    </div>
  </div>

  <script>
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');
    const scoreDisplay = document.getElementById('scoreDisplay');
    const finalScore = document.getElementById('finalScore');
    const startScreen = document.getElementById('startScreen');
    const gameOverScreen = document.getElementById('gameOverScreen');
    const altDisplay = document.getElementById('altDisplay');
    const spdDisplay = document.getElementById('spdDisplay');

    // Game state
    let gameRunning = false;
    let score = 0;
    let gameSpeed = 3;
    let spawnTimer = 0;
    let starTimer = 0;
    let powerupTimer = 0;
    let floatingTexts = [];

    // Player plane
    const plane = {
      x: 100,
      y: 250,
      width: 60,
      height: 30,
      velocityY: 0,
      gravity: 1,
      lift: -8,
      maxVelocity: 8
    };

    // Game objects
    let obstacles = [];
    let stars = [];
    let powerups = [];
    let clouds = [];
    let particles = [];
    let mountains = [];
    let trees = [];

    // Input handling
    const keys = {};
    document.addEventListener('keydown', (e) => {
      keys[e.code] = true;
      if (['ArrowUp', 'ArrowDown', 'Space', 'KeyW', 'KeyS'].includes(e.code)) {
        e.preventDefault();
      }
    });
    document.addEventListener('keyup', (e) => keys[e.code] = false);

    // Initialize environment
    function initEnvironment() {
      clouds = [];
      mountains = [];
      trees = [];

      // Clouds (high in sky)
      for (let i = 0; i < 6; i++) {
        clouds.push({
          x: Math.random() * canvas.width,
          y: Math.random() * 150 + 30,
          size: 30 + Math.random() * 50,
          speed: 0.3 + Math.random() * 0.5
        });
      }

      // Mountains (background layer)
      for (let i = 0; i < 8; i++) {
        mountains.push({
          x: i * 150 + Math.random() * 50,
          height: 80 + Math.random() * 60,
          width: 120 + Math.random() * 80,
          speed: 0.5
        });
      }

      // Trees (foreground layer)
      for (let i = 0; i < 15; i++) {
        trees.push({
          x: i * 80 + Math.random() * 40,
          height: 30 + Math.random() * 25,
          speed: 1.5
        });
      }
    }

    // Draw functions
    function drawPlane() {
      ctx.save();
      ctx.translate(plane.x + plane.width / 2, plane.y + plane.height / 2);

      // Tilt based on velocity
      const tilt = plane.velocityY * 2;
      ctx.rotate(tilt * Math.PI / 180);

      // F-35 Style Fighter Jet

      // Main fuselage (angular stealth shape)
      ctx.fillStyle = '#5a6a7a';
      ctx.beginPath();
      ctx.moveTo(30, 0);           // Nose
      ctx.lineTo(15, -6);          // Upper nose
      ctx.lineTo(-25, -8);         // Upper body
      ctx.lineTo(-30, -5);         // Tail top
      ctx.lineTo(-30, 5);          // Tail bottom
      ctx.lineTo(-25, 8);          // Lower body
      ctx.lineTo(15, 6);           // Lower nose
      ctx.closePath();
      ctx.fill();

      // Cockpit canopy
      ctx.fillStyle = '#4fc3f7';
      ctx.beginPath();
      ctx.moveTo(18, -4);
      ctx.lineTo(8, -7);
      ctx.lineTo(-5, -7);
      ctx.lineTo(-8, -4);
      ctx.lineTo(-5, -2);
      ctx.lineTo(15, -2);
      ctx.closePath();
      ctx.fill();

      // Cockpit frame
      ctx.strokeStyle = '#3a4a5a';
      ctx.lineWidth = 1;
      ctx.stroke();

      // Left wing (swept back delta)
      ctx.fillStyle = '#4a5a6a';
      ctx.beginPath();
      ctx.moveTo(5, -8);
      ctx.lineTo(-15, -28);
      ctx.lineTo(-25, -25);
      ctx.lineTo(-20, -8);
      ctx.closePath();
      ctx.fill();

      // Right wing
      ctx.beginPath();
      ctx.moveTo(5, 8);
      ctx.lineTo(-15, 28);
      ctx.lineTo(-25, 25);
      ctx.lineTo(-20, 8);
      ctx.closePath();
      ctx.fill();

      // Left horizontal stabilizer
      ctx.fillStyle = '#4a5a6a';
      ctx.beginPath();
      ctx.moveTo(-22, -8);
      ctx.lineTo(-28, -16);
      ctx.lineTo(-32, -14);
      ctx.lineTo(-28, -8);
      ctx.closePath();
      ctx.fill();

      // Right horizontal stabilizer
      ctx.beginPath();
      ctx.moveTo(-22, 8);
      ctx.lineTo(-28, 16);
      ctx.lineTo(-32, 14);
      ctx.lineTo(-28, 8);
      ctx.closePath();
      ctx.fill();

      // Vertical tail fins (dual canted)
      ctx.fillStyle = '#3a4a5a';
      ctx.beginPath();
      ctx.moveTo(-22, -6);
      ctx.lineTo(-26, -18);
      ctx.lineTo(-30, -16);
      ctx.lineTo(-28, -6);
      ctx.closePath();
      ctx.fill();

      ctx.beginPath();
      ctx.moveTo(-22, 6);
      ctx.lineTo(-26, 18);
      ctx.lineTo(-30, 16);
      ctx.lineTo(-28, 6);
      ctx.closePath();
      ctx.fill();

      // Engine exhaust glow
      ctx.fillStyle = '#ff6600';
      ctx.beginPath();
      ctx.ellipse(-32, 0, 6 + Math.random() * 4, 3, 0, 0, Math.PI * 2);
      ctx.fill();

      // Inner flame
      ctx.fillStyle = '#ffcc00';
      ctx.beginPath();
      ctx.ellipse(-31, 0, 3 + Math.random() * 2, 1.5, 0, 0, Math.PI * 2);
      ctx.fill();

      // Panel lines for detail
      ctx.strokeStyle = '#3a4a5a';
      ctx.lineWidth = 0.5;
      ctx.beginPath();
      ctx.moveTo(10, 0);
      ctx.lineTo(-20, 0);
      ctx.stroke();

      ctx.restore();
    }

    function drawObstacle(obs) {
      // Draw missile
      ctx.save();
      ctx.translate(obs.x + obs.width / 2, obs.y + obs.height / 2);

      // Missile body
      ctx.fillStyle = '#8b0000';
      ctx.beginPath();
      ctx.moveTo(25, 0);           // Nose tip
      ctx.lineTo(15, -6);
      ctx.lineTo(-20, -6);
      ctx.lineTo(-25, 0);
      ctx.lineTo(-20, 6);
      ctx.lineTo(15, 6);
      ctx.closePath();
      ctx.fill();

      // Nose cone
      ctx.fillStyle = '#4a4a4a';
      ctx.beginPath();
      ctx.moveTo(25, 0);
      ctx.lineTo(15, -5);
      ctx.lineTo(15, 5);
      ctx.closePath();
      ctx.fill();

      // Fins
      ctx.fillStyle = '#6b0000';
      ctx.beginPath();
      ctx.moveTo(-18, -6);
      ctx.lineTo(-25, -14);
      ctx.lineTo(-22, -6);
      ctx.closePath();
      ctx.fill();

      ctx.beginPath();
      ctx.moveTo(-18, 6);
      ctx.lineTo(-25, 14);
      ctx.lineTo(-22, 6);
      ctx.closePath();
      ctx.fill();

      // Engine exhaust
      ctx.fillStyle = '#ff4400';
      ctx.beginPath();
      ctx.ellipse(-27, 0, 5 + Math.random() * 3, 3, 0, 0, Math.PI * 2);
      ctx.fill();

      ctx.fillStyle = '#ffaa00';
      ctx.beginPath();
      ctx.ellipse(-26, 0, 2 + Math.random() * 2, 1.5, 0, 0, Math.PI * 2);
      ctx.fill();

      // Warning stripes
      ctx.fillStyle = '#ffcc00';
      ctx.fillRect(-5, -5, 3, 10);
      ctx.fillRect(2, -5, 3, 10);

      ctx.restore();
    }

    function drawStar(star) {
      ctx.save();
      ctx.translate(star.x + star.size / 2, star.y + star.size / 2);
      ctx.rotate(Date.now() / 500);

      ctx.fillStyle = '#ffd700';
      ctx.beginPath();
      for (let i = 0; i < 5; i++) {
        const angle = (i * 4 * Math.PI) / 5 - Math.PI / 2;
        const x = Math.cos(angle) * star.size / 2;
        const y = Math.sin(angle) * star.size / 2;
        if (i === 0) ctx.moveTo(x, y);
        else ctx.lineTo(x, y);
      }
      ctx.closePath();
      ctx.fill();

      // Glow effect
      ctx.shadowColor = '#ffd700';
      ctx.shadowBlur = 15;
      ctx.fill();

      ctx.restore();
    }

    function drawPowerup(powerup) {
      ctx.save();
      ctx.translate(powerup.x + powerup.size / 2, powerup.y + powerup.size / 2);

      // Pulsing effect
      const pulse = 1 + Math.sin(Date.now() / 150) * 0.15;
      ctx.scale(pulse, pulse);

      // Rainbow rotating glow
      const hue = (Date.now() / 10) % 360;
      ctx.shadowColor = `hsl(${hue}, 100%, 50%)`;
      ctx.shadowBlur = 25;

      // Outer rounded rectangle
      const w = powerup.size * 1.5;
      const h = powerup.size;
      ctx.fillStyle = `hsl(${hue}, 100%, 50%)`;
      ctx.beginPath();
      ctx.roundRect(-w / 2, -h / 2, w, h, 10);
      ctx.fill();

      // Inner rounded rectangle
      ctx.fillStyle = '#fff';
      ctx.beginPath();
      ctx.roundRect(-w / 2 + 4, -h / 2 + 4, w - 8, h - 8, 6);
      ctx.fill();

      // "Staš" text
      ctx.fillStyle = `hsl(${hue}, 100%, 40%)`;
      ctx.font = 'bold 20px Arial';
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      ctx.fillText('Staš', 0, 2);

      ctx.restore();
    }

    function drawFloatingText(ft) {
      ctx.save();
      ctx.globalAlpha = ft.alpha;
      ctx.fillStyle = '#00ff00';
      ctx.strokeStyle = '#005500';
      ctx.lineWidth = 3;
      ctx.font = 'bold 20px Arial';
      ctx.textAlign = 'center';
      ctx.strokeText('+' + ft.points.toLocaleString(), ft.x, ft.y);
      ctx.fillText('+' + ft.points.toLocaleString(), ft.x, ft.y);
      ctx.restore();
    }

    function drawCloud(cloud) {
      ctx.save();
      ctx.globalAlpha = 0.8;
      // Fluffy realistic cloud
      const gradient = ctx.createRadialGradient(cloud.x, cloud.y, 0, cloud.x, cloud.y, cloud.size);
      gradient.addColorStop(0, 'rgba(255, 255, 255, 0.9)');
      gradient.addColorStop(0.5, 'rgba(255, 255, 255, 0.6)');
      gradient.addColorStop(1, 'rgba(255, 255, 255, 0)');
      ctx.fillStyle = gradient;
      ctx.beginPath();
      ctx.arc(cloud.x, cloud.y, cloud.size, 0, Math.PI * 2);
      ctx.fill();
      ctx.beginPath();
      ctx.arc(cloud.x + cloud.size * 0.6, cloud.y - cloud.size * 0.15, cloud.size * 0.75, 0, Math.PI * 2);
      ctx.fill();
      ctx.beginPath();
      ctx.arc(cloud.x + cloud.size * 1.1, cloud.y + cloud.size * 0.1, cloud.size * 0.65, 0, Math.PI * 2);
      ctx.fill();
      ctx.beginPath();
      ctx.arc(cloud.x - cloud.size * 0.4, cloud.y + cloud.size * 0.1, cloud.size * 0.5, 0, Math.PI * 2);
      ctx.fill();
      ctx.restore();
    }

    function drawParticle(p) {
      ctx.fillStyle = `rgba(${p.color}, ${p.alpha})`;
      ctx.beginPath();
      ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
      ctx.fill();
    }

    function createParticles(x, y, color, count) {
      for (let i = 0; i < count; i++) {
        particles.push({
          x: x,
          y: y,
          vx: (Math.random() - 0.5) * 8,
          vy: (Math.random() - 0.5) * 8,
          size: Math.random() * 4 + 2,
          color: color,
          alpha: 1
        });
      }
    }

    function drawBackground() {
      // Sky gradient (more realistic)
      const skyGradient = ctx.createLinearGradient(0, 0, 0, canvas.height);
      skyGradient.addColorStop(0, '#1a4b8c');
      skyGradient.addColorStop(0.3, '#4a90c2');
      skyGradient.addColorStop(0.6, '#87ceeb');
      skyGradient.addColorStop(0.85, '#b8d4e8');
      skyGradient.addColorStop(1, '#d4e4d4');
      ctx.fillStyle = skyGradient;
      ctx.fillRect(0, 0, canvas.width, canvas.height);

      // Sun
      ctx.save();
      ctx.shadowColor = '#ffdd44';
      ctx.shadowBlur = 40;
      ctx.fillStyle = '#fff8dc';
      ctx.beginPath();
      ctx.arc(680, 60, 35, 0, Math.PI * 2);
      ctx.fill();
      ctx.restore();

      // Sun rays
      ctx.fillStyle = 'rgba(255, 248, 200, 0.1)';
      ctx.beginPath();
      ctx.arc(680, 60, 80, 0, Math.PI * 2);
      ctx.fill();

      // Draw clouds
      clouds.forEach(drawCloud);

      // Draw mountains (background)
      mountains.forEach(drawMountain);

      // Ground
      const groundGradient = ctx.createLinearGradient(0, canvas.height - 60, 0, canvas.height);
      groundGradient.addColorStop(0, '#4a7c23');
      groundGradient.addColorStop(0.5, '#3d6b1e');
      groundGradient.addColorStop(1, '#2d5016');
      ctx.fillStyle = groundGradient;
      ctx.fillRect(0, canvas.height - 60, canvas.width, 60);

      // Ground texture lines
      ctx.strokeStyle = '#3d6b1e';
      ctx.lineWidth = 1;
      for (let i = 0; i < canvas.width; i += 20) {
        ctx.beginPath();
        ctx.moveTo(i, canvas.height - 60);
        ctx.lineTo(i - 30, canvas.height);
        ctx.stroke();
      }

      // Draw trees (foreground)
      trees.forEach(drawTree);
    }

    function drawMountain(m) {
      // Back mountain (darker)
      ctx.fillStyle = '#5a7a5a';
      ctx.beginPath();
      ctx.moveTo(m.x, canvas.height - 60);
      ctx.lineTo(m.x + m.width / 2, canvas.height - 60 - m.height);
      ctx.lineTo(m.x + m.width, canvas.height - 60);
      ctx.closePath();
      ctx.fill();

      // Snow cap
      ctx.fillStyle = '#e8e8e8';
      ctx.beginPath();
      ctx.moveTo(m.x + m.width / 2, canvas.height - 60 - m.height);
      ctx.lineTo(m.x + m.width / 2 - 15, canvas.height - 60 - m.height + 20);
      ctx.lineTo(m.x + m.width / 2 + 15, canvas.height - 60 - m.height + 20);
      ctx.closePath();
      ctx.fill();
    }

    function drawTree(t) {
      const baseY = canvas.height - 60;

      // Trunk
      ctx.fillStyle = '#4a3728';
      ctx.fillRect(t.x - 3, baseY - t.height * 0.3, 6, t.height * 0.3);

      // Foliage layers
      ctx.fillStyle = '#2d5a1e';
      ctx.beginPath();
      ctx.moveTo(t.x, baseY - t.height);
      ctx.lineTo(t.x - 12, baseY - t.height * 0.4);
      ctx.lineTo(t.x + 12, baseY - t.height * 0.4);
      ctx.closePath();
      ctx.fill();

      ctx.fillStyle = '#3a7a28';
      ctx.beginPath();
      ctx.moveTo(t.x, baseY - t.height * 0.8);
      ctx.lineTo(t.x - 10, baseY - t.height * 0.25);
      ctx.lineTo(t.x + 10, baseY - t.height * 0.25);
      ctx.closePath();
      ctx.fill();
    }

    // Update functions
    function updatePlane() {
      // Apply controls
      if (keys['ArrowUp'] || keys['KeyW']) {
        plane.velocityY += plane.lift * 0.15;
      }
      if (keys['ArrowDown'] || keys['KeyS']) {
        plane.velocityY += 0.8;
      }

      // Apply gravity (lighter)
      plane.velocityY += plane.gravity * 0.5;

      // Clamp velocity
      plane.velocityY = Math.max(-plane.maxVelocity, Math.min(plane.maxVelocity, plane.velocityY));

      // Update position
      plane.y += plane.velocityY;

      // Boundary check (keep above ground)
      if (plane.y < 10) {
        plane.y = 10;
        plane.velocityY = 0;
      }
      if (plane.y + plane.height > canvas.height - 80) {
        plane.y = canvas.height - 80 - plane.height;
        plane.velocityY = 0;
      }
    }

    function updateObstacles() {
      spawnTimer++;
      if (spawnTimer > 200 - Math.min(score / 10, 40)) {
        spawnTimer = 0;
        obstacles.push({
          x: canvas.width,
          y: Math.random() * (canvas.height - 150) + 30,
          width: 50,
          height: 30,
          speed: gameSpeed + Math.random() * 2
        });
      }

      obstacles.forEach((obs, index) => {
        obs.x -= obs.speed;
        if (obs.x + obs.width < 0) {
          obstacles.splice(index, 1);
          score++;
          scoreDisplay.textContent = score.toLocaleString();
        }
      });
    }

    function updateStars() {
      starTimer++;
      if (starTimer > 120) {
        starTimer = 0;
        stars.push({
          x: canvas.width,
          y: Math.random() * (canvas.height - 140) + 20,
          size: 25,
          speed: gameSpeed
        });
      }

      stars.forEach((star, index) => {
        star.x -= star.speed;
        if (star.x + star.size < 0) {
          stars.splice(index, 1);
        }
      });
    }

    function updatePowerups() {
      powerupTimer++;
      // Spawn rarely (every ~5 seconds)
      if (powerupTimer > 300) {
        powerupTimer = 0;
        // Random points: 1 to 100
        const points = Math.floor(Math.random() * 1000) + 1;
        powerups.push({
          x: canvas.width,
          y: Math.random() * (canvas.height - 150) + 25,
          size: 40,
          speed: gameSpeed * 0.8,
          points: points
        });
      }

      powerups.forEach((powerup, index) => {
        powerup.x -= powerup.speed;
        if (powerup.x + powerup.size < 0) {
          powerups.splice(index, 1);
        }
      });
    }

    function updateFloatingTexts() {
      floatingTexts.forEach((ft, index) => {
        ft.y -= 1.5;
        ft.alpha -= 0.015;
        if (ft.alpha <= 0) {
          floatingTexts.splice(index, 1);
        }
      });
    }

    function updateEnvironment() {
      // Update clouds
      clouds.forEach(cloud => {
        cloud.x -= cloud.speed;
        if (cloud.x + cloud.size * 2 < 0) {
          cloud.x = canvas.width + cloud.size + 50;
          cloud.y = Math.random() * 150 + 30;
        }
      });

      // Update mountains (parallax - slow)
      mountains.forEach(m => {
        m.x -= m.speed;
        if (m.x + m.width < 0) {
          m.x = canvas.width + Math.random() * 100;
          m.height = 80 + Math.random() * 60;
          m.width = 120 + Math.random() * 80;
        }
      });

      // Update trees (parallax - faster)
      trees.forEach(t => {
        t.x -= t.speed;
        if (t.x < -20) {
          t.x = canvas.width + Math.random() * 50;
          t.height = 30 + Math.random() * 25;
        }
      });
    }

    function updateParticles() {
      particles.forEach((p, index) => {
        p.x += p.vx;
        p.y += p.vy;
        p.alpha -= 0.02;
        if (p.alpha <= 0) {
          particles.splice(index, 1);
        }
      });
    }

    function checkCollisions() {
      // Check obstacle collisions
      for (let obs of obstacles) {
        if (rectCollision(plane, obs)) {
          createParticles(plane.x + plane.width / 2, plane.y + plane.height / 2, '255, 100, 100', 20);
          gameOver();
          return;
        }
      }

      // Check star collection
      stars.forEach((star, index) => {
        const starRect = {x: star.x, y: star.y, width: star.size, height: star.size};
        if (rectCollision(plane, starRect)) {
          createParticles(star.x + star.size / 2, star.y + star.size / 2, '255, 215, 0', 15);
          stars.splice(index, 1);
          score += 5;
          scoreDisplay.textContent = score.toLocaleString();
        }
      });

      // Check Staš power-up collection
      powerups.forEach((powerup, index) => {
        const powerupRect = {x: powerup.x - powerup.size * 0.25, y: powerup.y, width: powerup.size * 1.5, height: powerup.size};
        if (rectCollision(plane, powerupRect)) {
          // Rainbow particles
          for (let i = 0; i < 25; i++) {
            const hue = Math.random() * 360;
            particles.push({
              x: powerup.x + powerup.size / 2,
              y: powerup.y + powerup.size / 2,
              vx: (Math.random() - 0.5) * 12,
              vy: (Math.random() - 0.5) * 12,
              size: Math.random() * 6 + 3,
              color: `${Math.floor(Math.random() * 255)}, ${Math.floor(Math.random() * 255)}, ${Math.floor(Math.random() * 255)}`,
              alpha: 1
            });
          }
          // Show floating points
          floatingTexts.push({
            x: powerup.x + powerup.size / 2,
            y: powerup.y,
            points: powerup.points,
            alpha: 1
          });
          powerups.splice(index, 1);
          score += powerup.points;
          scoreDisplay.textContent = score.toLocaleString();
        }
      });
    }

    function rectCollision(a, b) {
      const padding = 10; // Forgiving hitbox
      return a.x + padding < b.x + b.width - padding &&
        a.x + a.width - padding > b.x + padding &&
        a.y + padding < b.y + b.height - padding &&
        a.y + a.height - padding > b.y + padding;
    }

    // Game flow
    function startGame() {
      gameRunning = true;
      score = 0;
      gameSpeed = 3;
      spawnTimer = 0;
      starTimer = 0;
      powerupTimer = 0;
      obstacles = [];
      stars = [];
      powerups = [];
      particles = [];
      floatingTexts = [];
      plane.y = 250;
      plane.velocityY = 0;
      scoreDisplay.textContent = '0';
      startScreen.classList.add('hidden');
      gameOverScreen.classList.add('hidden');
      initEnvironment();
      gameLoop();
    }

    function gameOver() {
      gameRunning = false;
      finalScore.textContent = score.toLocaleString();
      gameOverScreen.classList.remove('hidden');
    }

    function gameLoop() {
      if (!gameRunning) return;

      // Clear canvas
      ctx.clearRect(0, 0, canvas.width, canvas.height);

      // Draw background
      drawBackground();

      // Update game objects
      updatePlane();
      updateObstacles();
      updateStars();
      updatePowerups();
      updateEnvironment();
      updateParticles();
      updateFloatingTexts();
      checkCollisions();

      // Increase difficulty
      gameSpeed = 3 + score / 50;

      // Update HUD
      const altitude = Math.floor((canvas.height - 80 - plane.y) * 100);
      const speed = Math.floor(200 + gameSpeed * 50);
      altDisplay.textContent = altitude;
      spdDisplay.textContent = speed;

      // Draw game objects
      stars.forEach(drawStar);
      powerups.forEach(drawPowerup);
      obstacles.forEach(drawObstacle);
      particles.forEach(drawParticle);
      floatingTexts.forEach(drawFloatingText);
      drawPlane();

      requestAnimationFrame(gameLoop);
    }

    // Initialize
    initEnvironment();
    drawBackground();
  </script>
</body>

</html>
